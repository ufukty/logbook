// validator is a code generator that generates a `Validate() error` function
// that contains every instance of constant in given type and declared in
// given file, as a positive value and returns an error for others. Such as:
//
//	func (p Planet) Validate() error {
//	  switch p {
//	  case Earth:
//	    return nil
//	  case Mars:
//	    return nil
//	  }
//	  return fmt.Errorf("invalid value")
//	}
package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"slices"
	"strings"
)

type Args struct {
	In   string
	Type string
}

func initial(s string) string {
	return strings.ToLower(string(s[0]))
}

func Main() error {
	args := Args{}

	flag.StringVar(&args.In, "in", "", "the filename that will be used for")
	flag.StringVar(&args.Type, "type", "", "the typename that will be used to filter-in constant specifications")
	flag.Parse()

	if args.In == "" || args.Type == "" {
		flag.PrintDefaults()
		return fmt.Errorf("bad arguments")
	}

	if !strings.HasSuffix(args.In, ".go") {
		return fmt.Errorf("input file is not a Go file")
	}

	f, err := parser.ParseFile(token.NewFileSet(), args.In, nil, parser.AllErrors)
	if err != nil {
		return fmt.Errorf("ParseFile: %w", err)
	}

	typ := ast.NewIdent(args.Type)
	recv := ast.NewIdent(initial(args.Type))
	collection := []*ast.Ident{}

	for _, d := range f.Decls {
		if gd, ok := d.(*ast.GenDecl); ok {
			if gd.Tok == token.CONST {
				for _, s := range gd.Specs {
					if vs, ok := s.(*ast.ValueSpec); ok {
						typematch := false
						if i, ok := vs.Type.(*ast.Ident); ok && i.Name == args.Type {
							typematch = true
						} else if len(vs.Values) > 0 {
							if ce, ok := vs.Values[0].(*ast.CallExpr); ok {
								if i, ok := ce.Fun.(*ast.Ident); ok && i.Name == args.Type {
									typematch = true
								}
							}
						}
						if typematch {
							collection = slices.Concat(collection, vs.Names)
						}
					}
				}
			}
		}
	}

	slices.SortFunc(collection, func(a, b *ast.Ident) int {
		if a.Name == b.Name {
			return 0
		} else if a.Name < b.Name {
			return -1
		}
		return 1
	})

	clauses := []ast.Stmt{}
	for _, i := range collection {
		clauses = append(clauses, &ast.CaseClause{
			List: []ast.Expr{i},
			Body: []ast.Stmt{&ast.ReturnStmt{Results: []ast.Expr{&ast.Ident{Name: "nil"}}}},
		})
	}

	g := &ast.File{
		Name: f.Name,
		Decls: []ast.Decl{
			&ast.GenDecl{
				Tok: token.IMPORT,
				Specs: []ast.Spec{
					&ast.ImportSpec{
						Name: nil,
						Path: &ast.BasicLit{
							Kind:  token.STRING,
							Value: "\"fmt\"",
						},
						Comment: nil,
					},
				},
			},
			&ast.FuncDecl{
				Recv: &ast.FieldList{List: []*ast.Field{{Names: []*ast.Ident{recv}, Type: typ}}},
				Name: ast.NewIdent("Validate"),
				Type: &ast.FuncType{
					Params:  &ast.FieldList{},
					Results: &ast.FieldList{List: []*ast.Field{{Type: ast.NewIdent("error")}}},
				},
				Body: &ast.BlockStmt{List: []ast.Stmt{
					&ast.SwitchStmt{
						Tag:  recv,
						Body: &ast.BlockStmt{List: clauses},
					},
					&ast.ReturnStmt{
						Results: []ast.Expr{&ast.CallExpr{
							Fun:  &ast.SelectorExpr{X: &ast.Ident{Name: "fmt"}, Sel: &ast.Ident{Name: "Errorf"}},
							Args: []ast.Expr{&ast.BasicLit{Kind: token.STRING, Value: "\"invalid value\""}},
						}},
					},
				}},
			},
		},
	}

	out := strings.TrimSuffix(args.In, ".go") + ".validate.go"
	h, err := os.Create(out)
	if err != nil {
		return fmt.Errorf("creating file: %w", err)
	}
	fmt.Fprint(h, "// Code generated by validator. DO NOT EDIT.\n\n")
	err = format.Node(h, token.NewFileSet(), g)
	if err != nil {
		return fmt.Errorf("printing new file: %w", err)
	}

	return nil
}

func main() {
	if err := Main(); err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
}
