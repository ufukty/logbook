// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.computed.sql

package database

import (
	"context"

	"logbook/models/columns"
)

const insertComputedToTop = `-- name: InsertComputedToTop :one
INSERT INTO "computed_to_top"("oid", "vid", "viewer", "is_solo", "is_completed", "index", "subtree_size", "completed_subitems")
    VALUES ("$1", "$2", "$3", "$4", "$5", "$6", "$7", "$8")
RETURNING
    oid, vid, viewer, is_solo, is_completed, index, subtree_size, completed_subitems
`

func (q *Queries) InsertComputedToTop(ctx context.Context) (ComputedToTop, error) {
	row := q.db.QueryRow(ctx, insertComputedToTop)
	var i ComputedToTop
	err := row.Scan(
		&i.Oid,
		&i.Vid,
		&i.Viewer,
		&i.IsSolo,
		&i.IsCompleted,
		&i.Index,
		&i.SubtreeSize,
		&i.CompletedSubitems,
	)
	return i, err
}

const selectComputedToTop = `-- name: SelectComputedToTop :one
SELECT
    oid, vid, viewer, is_solo, is_completed, index, subtree_size, completed_subitems
FROM
    "computed_to_top"
WHERE
    "oid" = $1
    AND "vid" = $2
    AND "viewer" = $3
LIMIT 1
`

type SelectComputedToTopParams struct {
	Oid    columns.ObjectiveId
	Vid    columns.VersionId
	Viewer columns.UserId
}

func (q *Queries) SelectComputedToTop(ctx context.Context, arg SelectComputedToTopParams) (ComputedToTop, error) {
	row := q.db.QueryRow(ctx, selectComputedToTop, arg.Oid, arg.Vid, arg.Viewer)
	var i ComputedToTop
	err := row.Scan(
		&i.Oid,
		&i.Vid,
		&i.Viewer,
		&i.IsSolo,
		&i.IsCompleted,
		&i.Index,
		&i.SubtreeSize,
		&i.CompletedSubitems,
	)
	return i, err
}
