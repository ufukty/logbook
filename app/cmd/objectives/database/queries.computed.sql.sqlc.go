// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.computed.sql

package database

import (
	"context"

	"logbook/models/columns"
)

const insertComputedToTop = `-- name: InsertComputedToTop :one
INSERT INTO "computed_to_top"("oid", "vid", "is_in_collaboration")
    VALUES ("$1", "$2", "$3")
RETURNING
    id, oid, vid, is_in_collaboration
`

func (q *Queries) InsertComputedToTop(ctx context.Context) (ComputedToTop, error) {
	row := q.db.QueryRow(ctx, insertComputedToTop)
	var i ComputedToTop
	err := row.Scan(
		&i.ID,
		&i.Oid,
		&i.Vid,
		&i.IsInCollaboration,
	)
	return i, err
}

const insertComputedToTopCollaborated = `-- name: InsertComputedToTopCollaborated :one
INSERT INTO "computed_to_top_collaborated"("oid", "vid", "viewer", "is_completed", "subtree_size", "completed_subitems")
    VALUES ("$1", "$2", "$3", "$4", "$5", "$6")
RETURNING
    oid, vid, viewer, is_completed, subtree_size, completed_subitems
`

func (q *Queries) InsertComputedToTopCollaborated(ctx context.Context) (ComputedToTopCollaborated, error) {
	row := q.db.QueryRow(ctx, insertComputedToTopCollaborated)
	var i ComputedToTopCollaborated
	err := row.Scan(
		&i.Oid,
		&i.Vid,
		&i.Viewer,
		&i.IsCompleted,
		&i.SubtreeSize,
		&i.CompletedSubitems,
	)
	return i, err
}

const insertComputedToTopCollaborator = `-- name: InsertComputedToTopCollaborator :one
INSERT INTO "computed_to_top_collaborator"("oid", "vid", "viewer", "subtree_size", "completed_subitems")
    VALUES ("$1", "$2", "$3", "$4", "$5")
RETURNING
    oid, vid, viewer, subtree_size, completed_subitems
`

func (q *Queries) InsertComputedToTopCollaborator(ctx context.Context) (ComputedToTopCollaborator, error) {
	row := q.db.QueryRow(ctx, insertComputedToTopCollaborator)
	var i ComputedToTopCollaborator
	err := row.Scan(
		&i.Oid,
		&i.Vid,
		&i.Viewer,
		&i.SubtreeSize,
		&i.CompletedSubitems,
	)
	return i, err
}

const insertComputedToTopSolo = `-- name: InsertComputedToTopSolo :one
INSERT INTO "computed_to_top_solo"("oid", "vid", "viewer", "is_completed", "subtree_size", "completed_subitems")
    VALUES ("$1", "$2", "$3", "$4", "$5", "$6")
RETURNING
    oid, vid, viewer, is_completed, subtree_size, completed_subitems
`

func (q *Queries) InsertComputedToTopSolo(ctx context.Context) (ComputedToTopSolo, error) {
	row := q.db.QueryRow(ctx, insertComputedToTopSolo)
	var i ComputedToTopSolo
	err := row.Scan(
		&i.Oid,
		&i.Vid,
		&i.Viewer,
		&i.IsCompleted,
		&i.SubtreeSize,
		&i.CompletedSubitems,
	)
	return i, err
}

const selectComputedToTop = `-- name: SelectComputedToTop :one
SELECT
    id, oid, vid, is_in_collaboration
FROM
    "computed_to_top"
WHERE
    "oid" = $1
    AND "vid" = $2
LIMIT 1
`

type SelectComputedToTopParams struct {
	Oid columns.ObjectiveId
	Vid columns.VersionId
}

func (q *Queries) SelectComputedToTop(ctx context.Context, arg SelectComputedToTopParams) (ComputedToTop, error) {
	row := q.db.QueryRow(ctx, selectComputedToTop, arg.Oid, arg.Vid)
	var i ComputedToTop
	err := row.Scan(
		&i.ID,
		&i.Oid,
		&i.Vid,
		&i.IsInCollaboration,
	)
	return i, err
}

const selectComputedToTopCollaborated = `-- name: SelectComputedToTopCollaborated :one
SELECT
    oid, vid, viewer, is_completed, subtree_size, completed_subitems
FROM
    "computed_to_top_collaborated"
WHERE
    "oid" = $1
    AND "vid" = $2
    AND "viewer" = $3
LIMIT 1
`

type SelectComputedToTopCollaboratedParams struct {
	Oid    columns.ObjectiveId
	Vid    columns.VersionId
	Viewer columns.CollaborationId
}

func (q *Queries) SelectComputedToTopCollaborated(ctx context.Context, arg SelectComputedToTopCollaboratedParams) (ComputedToTopCollaborated, error) {
	row := q.db.QueryRow(ctx, selectComputedToTopCollaborated, arg.Oid, arg.Vid, arg.Viewer)
	var i ComputedToTopCollaborated
	err := row.Scan(
		&i.Oid,
		&i.Vid,
		&i.Viewer,
		&i.IsCompleted,
		&i.SubtreeSize,
		&i.CompletedSubitems,
	)
	return i, err
}

const selectComputedToTopCollaborator = `-- name: SelectComputedToTopCollaborator :one
SELECT
    oid, vid, viewer, subtree_size, completed_subitems
FROM
    "computed_to_top_collaborator"
WHERE
    "oid" = $1
    AND "vid" = $2
    AND "viewer" = $3
LIMIT 1
`

type SelectComputedToTopCollaboratorParams struct {
	Oid    columns.ObjectiveId
	Vid    columns.VersionId
	Viewer columns.UserId
}

func (q *Queries) SelectComputedToTopCollaborator(ctx context.Context, arg SelectComputedToTopCollaboratorParams) (ComputedToTopCollaborator, error) {
	row := q.db.QueryRow(ctx, selectComputedToTopCollaborator, arg.Oid, arg.Vid, arg.Viewer)
	var i ComputedToTopCollaborator
	err := row.Scan(
		&i.Oid,
		&i.Vid,
		&i.Viewer,
		&i.SubtreeSize,
		&i.CompletedSubitems,
	)
	return i, err
}

const selectComputedToTopSolo = `-- name: SelectComputedToTopSolo :one
SELECT
    oid, vid, viewer, is_completed, subtree_size, completed_subitems
FROM
    "computed_to_top_solo"
WHERE
    "oid" = $1
    AND "vid" = $2
    AND "viewer" = $3
LIMIT 1
`

type SelectComputedToTopSoloParams struct {
	Oid    columns.ObjectiveId
	Vid    columns.VersionId
	Viewer columns.UserId
}

func (q *Queries) SelectComputedToTopSolo(ctx context.Context, arg SelectComputedToTopSoloParams) (ComputedToTopSolo, error) {
	row := q.db.QueryRow(ctx, selectComputedToTopSolo, arg.Oid, arg.Vid, arg.Viewer)
	var i ComputedToTopSolo
	err := row.Scan(
		&i.Oid,
		&i.Vid,
		&i.Viewer,
		&i.IsCompleted,
		&i.SubtreeSize,
		&i.CompletedSubitems,
	)
	return i, err
}

const updateComputedToTop = `-- name: UpdateComputedToTop :one
UPDATE
    "computed_to_top"
SET
    "is_in_collaboration" = $3
WHERE
    "oid" = $1
    AND "vid" = $2
RETURNING
    id, oid, vid, is_in_collaboration
`

type UpdateComputedToTopParams struct {
	Oid               columns.ObjectiveId
	Vid               columns.VersionId
	IsInCollaboration bool
}

func (q *Queries) UpdateComputedToTop(ctx context.Context, arg UpdateComputedToTopParams) (ComputedToTop, error) {
	row := q.db.QueryRow(ctx, updateComputedToTop, arg.Oid, arg.Vid, arg.IsInCollaboration)
	var i ComputedToTop
	err := row.Scan(
		&i.ID,
		&i.Oid,
		&i.Vid,
		&i.IsInCollaboration,
	)
	return i, err
}
